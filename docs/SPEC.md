# SPEC – MandalorMarket (architecture, data, API, DoD)

> Generated by /orchestrate — Source of truth: `docs/PRD.md`

## Scope (PRD recap)

- **Ce qu’on construit**: un site e‑commerce fictif “MandalorMarket” (inspiration Star Wars, UI sobre) avec catalogue, recherche/filtres, panier, checkout et commandes simulées.
- **Pour qui**: démo technique pour recruteurs + usage réaliste pour clients/vendeurs/admin (marketplace multi‑vendeurs).
- **Core flows**: visite & achat (invité ou connecté) → commande → suivi; inscription vendeur → approbation admin → vente & expédition; admin → maîtrise totale du site.
- **Must-have**: vues client/vendeur/admin, homepage riche, pages produits, collections, tri façon Shopify, dashboards chiffrés, avis (1–5 étoiles, 1 avis/user/produit acheté), Supabase Auth + Prisma + Supabase Postgres.
- **Contraintes**: monorepo `pnpm`, Next.js App Router + Tailwind + shadcn/ui, NestJS, français, dark mode par défaut (accent beskar), déploiement Vercel, DB managée Supabase.

## Overview

MandalorMarket est un POC e‑commerce full‑stack (Next.js + NestJS) conçu comme une application “type produit pro” : rôles, marketplace multi‑vendeurs, gestion des commandes/expéditions, avis et dashboards. L’authentification est fournie par Supabase Auth et la persistance par PostgreSQL Supabase, accédée via Prisma depuis l’API Nest.

## Architecture

### Monorepo (pnpm workspaces)

Proposition de structure (à confirmer/adapter au repo existant lors du Build) :

- `apps/web/` – Frontend Next.js (App Router)
  - `app/` routes: `/`, `/catalogue`, `/produits/[slug]`, `/collections`, `/collections/[slug]`, `/promos`, `/panier`, `/checkout`, `/compte`, `/vendeur/*`, `/admin/*`, `/contact`
  - `components/` UI + composants métier (cards produits, filtres, tableaux, charts)
  - `lib/` clients API, client Supabase, helpers (format crédits, etc.)
  - `styles/` theme Tailwind + tokens (palette dark + accent “beskar”)
- `apps/api/` – Backend NestJS
  - `src/modules/auth/` guards + vérification tokens Supabase
  - `src/modules/products/` catalogue + recherche/filtres/tri
  - `src/modules/collections/` collections et assignations
  - `src/modules/orders/` checkout + commandes + items + statuts
  - `src/modules/reviews/` avis + règles “acheté” + modération admin
  - `src/modules/vendor/` dashboard vendeur (metrics, commandes, produits)
  - `src/modules/admin/` gestion globale (users/roles, vendor applications, modération)
  - `src/prisma/` prisma client + migrations + seed
- `packages/shared/` (optionnel) – types partagés, schémas Zod, constantes (roles, enums)
- `docs/` – PRD, SPEC, BACKLOG

### Communication web ↔ api

- Le frontend appelle l’API via HTTP (JSON).
- Auth côté front: Supabase Auth (email+password) fournit une session et un access token.
- L’API Nest reçoit l’access token (Bearer) et le valide pour autoriser les routes.

### UI / design system

- **Tailwind CSS + shadcn/ui** pour la base composant.
- Dark mode par défaut, accent “beskar” (or/jaune) + gris/charbon.
- Effets subtils (hover, transitions, micro‑animations non dominantes).

## Data model

### Identité & rôles

> Les utilisateurs sont gérés par Supabase Auth. Le backend persiste un profil/applicatif associé via `authUserId` (UUID).

- **UserProfile**
  - `id` (uuid, PK) = `authUserId` (Supabase)
  - `email` (string, unique, redondant pour affichage)
  - `displayName` (string, nullable)
  - `role` (enum: `CLIENT` | `VENDOR` | `ADMIN`) — rôle principal
  - `vendorStatus` (enum: `NONE` | `PENDING` | `APPROVED` | `REJECTED`)
  - `createdAt`, `updatedAt`

- **VendorApplication**
  - `id` (uuid, PK)
  - `userId` (uuid, FK -> UserProfile)
  - `status` (enum: `PENDING` | `APPROVED` | `REJECTED`)
  - `note` (string, nullable) — message vendeur / commentaire admin
  - `reviewedByAdminUserId` (uuid, nullable)
  - `reviewedAt` (datetime, nullable)
  - `createdAt`, `updatedAt`

### Catalogue

- **Product**
  - `id` (uuid, PK)
  - `sellerUserId` (uuid, FK -> UserProfile) — vendeur propriétaire
  - `type` (enum: `BLASTER` | `FORMATION` | `CREDIT` | `OTHER`)
  - `name` (string)
  - `slug` (string, unique)
  - `description` (text)
  - `priceCredits` (int) — 1 crédit = 1 €
  - `stock` (int)
  - `brand` (string, nullable)
  - `originCountry` (string, nullable) — “origine”
  - `sizeLabel` (string, nullable) — “grandeur”
  - `isFeatured` (bool)
  - `isOnSale` (bool)
  - `salePriceCredits` (int, nullable)
  - `popularityScore` (int, default 0) — heuristique (ventes, vues…)
  - `createdAt`, `updatedAt`

- **ProductImage**
  - `id` (uuid, PK)
  - `productId` (uuid, FK -> Product)
  - `url` (string)
  - `alt` (string, nullable)
  - `position` (int)

- **Collection**
  - `id` (uuid, PK)
  - `name` (string)
  - `slug` (string, unique)
  - `description` (text, nullable) — texte “un peu Star Wars” autorisé
  - `heroImageUrl` (string, nullable)
  - `createdAt`, `updatedAt`

- **CollectionProduct** (join)
  - `collectionId` (uuid, FK -> Collection)
  - `productId` (uuid, FK -> Product)

### Commandes (paiement simulé) & expéditions

> L’objectif est une marketplace: une commande peut contenir des produits de plusieurs vendeurs. Le suivi vendeur se fait au niveau des items.

- **Order**
  - `id` (uuid, PK)
  - `userId` (uuid, nullable, FK -> UserProfile) — null si checkout invité
  - `status` (enum: `PENDING` | `PAID` | `SHIPPED` | `CANCELLED`)
  - `currency` (string, default `CREDITS`)
  - `totalCredits` (int)
  - `customerEmail` (string)
  - `customerFirstName` / `customerLastName` (string)
  - `billingAddress` (json) — adresse complète
  - `shippingAddress` (json) — adresse complète (peut = billing)
  - `createdAt`, `updatedAt`

- **OrderItem**
  - `id` (uuid, PK)
  - `orderId` (uuid, FK -> Order)
  - `productId` (uuid, FK -> Product)
  - `sellerUserId` (uuid, FK -> UserProfile) — redondant pour requêtes vendeur
  - `unitPriceCredits` (int)
  - `quantity` (int)
  - `lineTotalCredits` (int)
  - `fulfillmentStatus` (enum: `PENDING` | `SHIPPED` | `CANCELLED`)
  - `shippedAt` (datetime, nullable)

### Avis

- **Review**
  - `id` (uuid, PK)
  - `productId` (uuid, FK -> Product)
  - `userId` (uuid, FK -> UserProfile)
  - `rating` (int, 1..5)
  - `comment` (text, nullable)
  - `createdAt`, `updatedAt`
  - Contrainte unique: `(productId, userId)`

Règle d’éligibilité:
- un user peut laisser un avis **uniquement** s’il existe au moins un `OrderItem` correspondant à `(userId, productId)` sur une commande en état **livré**.
  - Décision: dans ce POC, “livré” sera interprété comme `Order.status = SHIPPED` *ou* `OrderItem.fulfillmentStatus = SHIPPED` (à fixer pendant le Build).

## API contract

### Conventions

- Base URL: `/api`
- JSON uniquement.
- Erreurs (format):
  - `code` (string), `message` (string), `details` (object|null)
- Pagination:
  - `page`, `pageSize`, `total`, `items`
- Auth:
  - `Authorization: Bearer <supabase_access_token>` pour routes protégées
  - Si token absent/invalid: `401`
  - Si rôle insuffisant: `403`

### Public

- `GET /products`
  - Query: `q`, `type`, `minPrice`, `maxPrice`, `originCountry`, `brand`, `size`, `inStock`, `collectionSlug`, `sort` (`price_asc|price_desc|newest|oldest|popular`)
  - Response: paginé, inclut `ratingAvg`, `ratingCount`, `sellerName` (ou vendeur id)

- `GET /products/:slug`
  - Response: détails + images + infos vendeur (affichage) + avis paginés

- `GET /collections`
  - Response: liste collections

- `GET /collections/:slug`
  - Response: détails collection + produits (paginés, filtres hérités)

- `POST /checkout`
  - Auth: optionnel (invité autorisé)
  - Body: `items[{productId, quantity}]`, `customer`, `billingAddress`, `shippingAddress`, options livraison (simple)
  - Response: `orderId`, `status`, `totalCredits`
  - Erreurs: stock insuffisant (`409`), validation (`400`)

### Authenticated (client)

- `GET /me`
  - Retourne profil (role, vendorStatus) + flags UI

- `GET /me/orders`
  - Historique commandes (uniquement userId non-null)

- `GET /me/orders/:orderId`
  - Détails (items) + adresses + statuts

- `POST /products/:productId/reviews`
  - Body: `rating`, `comment?`
  - Règles: 1 review max; “purchased & delivered” requis.

- `PATCH /reviews/:reviewId` (owner ou admin)
- `DELETE /reviews/:reviewId` (owner ou admin)

### Vendor (role = VENDOR, vendorStatus = APPROVED) / Admin

- `GET /vendor/dashboard`
  - Response: KPIs (CA crédits, # commandes, panier moyen, top produits, pending shipments, courbes 7/30j, taux annulation, taux avis +/-)

- `GET /vendor/products`
- `POST /vendor/products`
- `PATCH /vendor/products/:productId`
- `DELETE /vendor/products/:productId`

- `GET /vendor/orders`

- `PATCH /vendor/order-items/:orderItemId/fulfillment`
  - Body: `fulfillmentStatus`

### Admin (role = ADMIN)

- `GET /admin/vendor-applications`
- `PATCH /admin/vendor-applications/:id`
  - Body: `status`, `note?`

- `GET /admin/users`
- `PATCH /admin/users/:userId`
  - Body: `role`, `vendorStatus?`

- `GET /admin/orders`
- `PATCH /admin/orders/:orderId/status`

- `GET /admin/products`

- `PATCH /admin/reviews/:reviewId`
- `DELETE /admin/reviews/:reviewId`

## Non-functional requirements

- **Performance**
  - Listes produits/collections/avis paginées.
  - Index DB à prévoir sur: `Product.slug`, `Product.sellerUserId`, `Product.createdAt`, `Product.isOnSale`, `Product.isFeatured`, `Order.userId`, `Order.createdAt`, `OrderItem.sellerUserId`, `Review.productId`.
- **Sécurité (bases)**
  - Vérification systématique du token Supabase sur routes protégées.
  - Autorisation par rôle + ownership (vendeur sur ses produits/items).
  - Validation d’entrée (DTO) et messages d’erreurs non verbeux.
  - Variables d’env non commitées, séparation clés publiques/privées Supabase.
- **Qualité**
  - API contract stable et typé (types partagés/DTO).
  - Logs suffisants côté API pour debug POC.

## Assumptions & decisions

- **Supabase utilisé pour 2 choses**: Auth + PostgreSQL managé.  
  Décision: **toutes les écritures/lectures DB passent par l’API Nest via Prisma**, le frontend n’accède pas directement à la DB Supabase.
- **Checkout invité**: `Order.userId` peut être `null`. Le “Mon compte” et l’historique ne concernent que les utilisateurs connectés.
- **Multi-vendeurs**: une commande peut contenir plusieurs vendeurs; le suivi vendeur est calculé sur `OrderItem` filtré par `sellerUserId`.
- **Promos & recommandations**: implémentation rule-based (flags `isOnSale`, `isFeatured`, tri par popularité).
- **Libs candidates (à valider avant usage en Build)**:
  - Charts dashboards: `recharts` ou `@tremor/react`
  - State panier: `zustand` (ou alternative)
  - Data fetching: `@tanstack/react-query` (optionnel)

## Definition of Done (DoD)

- **Fonctionnel**
  - Parcours client (invité) complet: homepage → catalogue (recherche/filtres/tri) → fiche produit → panier → checkout → confirmation.
  - Parcours client (connecté): “Mon compte” + historique commandes + gestion avis éligibles.
  - Parcours vendeur: inscription vendeur → demande → approbation admin → dashboard vendeur (KPIs) → CRUD produits → gestion expéditions.
  - Parcours admin: gestion totale (users/roles, demandes vendeurs, catalogue, commandes, avis).
  - Avis: 1 avis/user/produit acheté; vendeur lecture seule; admin contrôle total.
- **UX/UI**
  - Français, dark mode par défaut, design sobre avec accent beskar, responsive (desktop-first).
  - Navbar: logo, recherche, catégories (avec sous‑menus), compte, panier, promos.
  - Pages collections + template collection.
- **Qualité & maintenabilité**
  - Validation d’entrées côté API.
  - Seed de ~20 produits + collections + comptes démo (admin, vendeur, client).
  - `docs/PRD.md`, `docs/SPEC.md`, `docs/BACKLOG.md` à jour.